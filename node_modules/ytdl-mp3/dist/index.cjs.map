{"version":3,"sources":["../src/index.ts","../src/Downloader.ts","../src/FormatConverter.ts","../src/utils.ts","../src/SongTagsSearch.ts"],"sourcesContent":["export * from './Downloader';\nexport * from './FormatConverter';\nexport * from './SongTagsSearch';\nexport { YtdlMp3Error } from './utils';\n","import os from 'os';\nimport path from 'path';\n\nimport ytdl from '@distube/ytdl-core';\nimport type { videoInfo as VideoInfo } from '@distube/ytdl-core';\nimport NodeID3 from 'node-id3';\n\nimport { FormatConverter } from './FormatConverter';\nimport { SongTagsSearch } from './SongTagsSearch';\nimport { isDirectory, removeParenthesizedText, YtdlMp3Error } from './utils';\n\nimport type { SongTags } from './SongTagsSearch';\n\ntype DownloaderOptions = {\n  customSearchTerm?: null | string;\n  getTags?: boolean;\n  outputDir?: string;\n  silentMode?: boolean;\n  verifyTags?: boolean;\n};\n\ntype DownloaderItemInformation = {\n  album: null | string;\n  artist: null | string;\n  genre: null | string;\n  outputFile: string;\n  trackNo: null | number;\n  year: null | string;\n};\n\nexport class Downloader {\n  static defaultDownloadsDir = path.join(os.homedir(), 'Downloads');\n\n  customSearchTerm: null | string;\n  getTags: boolean;\n  outputDir: string;\n  silentMode: boolean;\n  verifyTags: boolean;\n\n  constructor({ customSearchTerm, getTags, outputDir, silentMode, verifyTags }: DownloaderOptions) {\n    this.outputDir = outputDir ?? Downloader.defaultDownloadsDir;\n    this.getTags = Boolean(getTags);\n    this.silentMode = Boolean(silentMode);\n    this.verifyTags = Boolean(verifyTags);\n    this.customSearchTerm = customSearchTerm ?? null;\n  }\n\n  async downloadSong(url: string): Promise<DownloaderItemInformation> {\n    if (!isDirectory(this.outputDir)) {\n      throw new YtdlMp3Error(`Not a directory: ${this.outputDir}`);\n    }\n    const videoInfo = await ytdl.getInfo(url).catch((error) => {\n      throw new YtdlMp3Error(`Failed to fetch info for video with URL: ${url}`, {\n        cause: error\n      });\n    });\n\n    const formatConverter = new FormatConverter();\n    const songTagsSearch = new SongTagsSearch(\n      this.customSearchTerm\n        ? this.customSearchTerm\n            .replaceAll('{title}', videoInfo.videoDetails.title)\n            .replaceAll('{uploader}', videoInfo.videoDetails.author.name)\n        : videoInfo.videoDetails.title\n    );\n\n    const outputFile = this.getOutputFile(videoInfo.videoDetails.title);\n    const videoData = await this.downloadVideo(videoInfo).catch((error) => {\n      throw new YtdlMp3Error('Failed to download video', {\n        cause: error\n      });\n    });\n\n    formatConverter.videoToAudio(videoData, outputFile);\n    let songTags: null | SongTags = null;\n    if (this.getTags) {\n      songTags = await songTagsSearch.search(this.verifyTags);\n      NodeID3.write(songTags, outputFile);\n    }\n\n    if (!this.silentMode) {\n      console.log(`Done! Output file: ${outputFile}`);\n    }\n\n    return {\n      album: songTags?.album ?? null,\n      artist: songTags?.artist ?? null,\n      genre: songTags?.genre ?? null,\n      outputFile,\n      trackNo: songTags?.TRCK ?? null,\n      year: songTags?.year ?? null\n    };\n  }\n\n  /** Returns the content from the video as a buffer */\n  private async downloadVideo(videoInfo: VideoInfo): Promise<Buffer> {\n    const buffers: Buffer[] = [];\n    const stream = ytdl.downloadFromInfo(videoInfo, { quality: 'highestaudio' });\n    return new Promise((resolve, reject) => {\n      stream.on('data', (chunk: Buffer) => {\n        buffers.push(chunk);\n      });\n      stream.on('end', () => {\n        resolve(Buffer.concat(buffers));\n      });\n      stream.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  /** Returns the absolute path to the audio file to be downloaded */\n  private getOutputFile(videoTitle: string): string {\n    const baseFileName = removeParenthesizedText(videoTitle)\n      .replace(/[^a-z0-9]/gi, '_')\n      .split('_')\n      .filter((element) => element)\n      .join('_')\n      .toLowerCase();\n    return path.join(this.outputDir, baseFileName + '.mp3');\n  }\n}\n\nexport type { DownloaderOptions };\n","import cp from 'child_process';\nimport fs from 'fs';\n\nimport ffmpeg from 'ffmpeg-static';\n\nimport { YtdlMp3Error } from './utils';\n\nexport class FormatConverter {\n  private readonly ffmpegBinary: string;\n\n  constructor() {\n    if (!ffmpeg) {\n      throw new YtdlMp3Error('Failed to resolve ffmpeg binary');\n    }\n    this.ffmpegBinary = ffmpeg;\n  }\n\n  videoToAudio(videoData: Buffer, outputFile: string): void {\n    if (fs.existsSync(outputFile)) {\n      throw new YtdlMp3Error(`Output file already exists: ${outputFile}`);\n    }\n    cp.execSync(`${this.ffmpegBinary} -loglevel 24 -i pipe:0 -vn -sn -c:a mp3 -ab 192k ${outputFile}`, {\n      input: videoData\n    });\n  }\n}\n","import fs from 'fs';\nimport readline from 'readline';\n\n/**\n * Removes content within square brackets or parentheses, including the brackets and\n * parentheses themselves, along with any surrounding whitespace, from the given string.\n *\n * @param input the input string from which to remove content within brackets and parentheses.\n * @returns a new string with content within brackets and parentheses removed.\n */\nexport function removeParenthesizedText(s: string): string {\n  // This loop is to handle nested nested brackets (see test for examples)\n  const regex = /\\s*([[(][^[\\]()]*[\\])])\\s*/g;\n  while (regex.test(s)) {\n    s = s.replace(regex, '');\n  }\n  return s;\n}\n\n/**\n * Checks if the given path corresponds to a directory.\n *\n * @param path - the path to check.\n * @returns `true` if the path exists and is a directory, `false` otherwise.\n */\nexport function isDirectory(path: string): boolean {\n  return fs.existsSync(path) && fs.lstatSync(path).isDirectory();\n}\n\n/**\n * Prompts the user for input via stdin and returns a promise that resolves to the user's input.\n *\n * @param prompt - the prompt text displayed to the user.\n * @param defaultInput - optional default input pre-filled in the prompt.\n * @returns a promise that resolves to the user's input\n */\nexport async function userInput(prompt: string, defaultInput?: string): Promise<string> {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n  });\n  return new Promise((resolve, reject) => {\n    rl.question(prompt, (response) => {\n      rl.close();\n      if (response) {\n        resolve(response);\n      } else {\n        reject(new YtdlMp3Error('Invalid response: ' + response));\n      }\n    });\n    rl.write(defaultInput ?? '');\n  });\n}\n\n/**\n * Custom error class representing unrecoverable errors intentionally thrown by ytdl-mp3\n */\nexport class YtdlMp3Error extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = 'YtdlMp3Error';\n  }\n}\n","import axios from 'axios';\nimport type { AxiosError } from 'axios';\n\nimport { removeParenthesizedText, userInput, YtdlMp3Error } from './utils';\n\nexport type SearchResult = {\n  artistName: string;\n  artworkUrl100: string;\n  collectionName: string;\n  primaryGenreName: string;\n  releaseDate: string;\n  trackName: string;\n  trackNumber: number;\n};\n\nexport type SearchData = {\n  resultCount: number;\n  results: SearchResult[];\n};\n\nexport type AlbumArt = {\n  description: string;\n  imageBuffer: Buffer;\n  mime: string;\n  type: number;\n};\n\nexport type SongTags = {\n  album: string;\n  APIC: AlbumArt;\n  artist: string;\n  genre: string;\n  title: string;\n  TRCK: number;\n  year: string;\n};\n\nexport class SongTagsSearch {\n  private searchTerm: string;\n  private url: URL;\n\n  constructor(searchTerm: string) {\n    this.searchTerm = removeParenthesizedText(searchTerm);\n    this.url = new URL('https://itunes.apple.com/search?');\n    this.url.searchParams.set('media', 'music');\n    this.url.searchParams.set('term', this.searchTerm);\n  }\n\n  async search(verify = false): Promise<SongTags> {\n    console.log(`Attempting to query iTunes API with the following search term: ${this.searchTerm}`);\n    const searchResults = await this.fetchResults();\n    const result = verify ? await this.getVerifiedResult(searchResults) : searchResults[0]!;\n    const artworkUrl = result.artworkUrl100.replace('100x100bb.jpg', '600x600bb.jpg');\n    const albumArt = await this.fetchAlbumArt(artworkUrl);\n    return {\n      album: result.collectionName,\n      APIC: {\n        description: 'Album Art',\n        imageBuffer: albumArt,\n        mime: 'image/jpeg',\n        type: 3\n      },\n      artist: result.artistName,\n      genre: result.primaryGenreName,\n      title: result.trackName,\n      TRCK: result.trackNumber,\n      year: result.releaseDate.substring(0, 4)\n    };\n  }\n\n  private async fetchAlbumArt(url: string): Promise<Buffer> {\n    return axios\n      .get(url, { responseType: 'arraybuffer' })\n      .then((response) => Buffer.from(response.data as string, 'binary'))\n      .catch(() => {\n        throw new YtdlMp3Error('Failed to fetch album art from endpoint: ' + url);\n      });\n  }\n\n  private async fetchResults(): Promise<SearchResult[]> {\n    const response = await axios.get<SearchData>(this.url.href).catch((error: AxiosError) => {\n      if (error.response?.status) {\n        throw new YtdlMp3Error(`Call to iTunes API returned status code ${error.response.status}`);\n      }\n      throw new YtdlMp3Error('Call to iTunes API failed and did not return a status');\n    });\n\n    if (response.data.resultCount === 0) {\n      throw new YtdlMp3Error('Call to iTunes API did not return any results');\n    }\n\n    return response.data.results;\n  }\n\n  private async getVerifiedResult(searchResults: SearchResult[]): Promise<SearchResult> {\n    for (const result of searchResults) {\n      console.log('The following tags were extracted from iTunes:');\n      console.log('Title: ' + result.trackName);\n      console.log('Artist: ' + result.artistName);\n      console.log('Album: ' + result.collectionName);\n      console.log('Genre: ' + result.primaryGenreName);\n\n      const validResponses = ['Y', 'YES', 'N', 'NO'];\n      let userSelection = (await userInput('Please verify (Y/N): ')).toUpperCase();\n      while (!validResponses.includes(userSelection)) {\n        console.error('Invalid selection, try again!');\n        userSelection = (await userInput('Please verify (Y/N): ')).toUpperCase();\n      }\n      if (userSelection === 'Y' || userSelection === 'YES') {\n        return result;\n      }\n    }\n    throw new YtdlMp3Error('End of results');\n  }\n}\n"],"mappings":"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","names":["import_fs","path","fs","readline","ffmpeg","fs","cp","axios","path","os","ytdl","NodeID3"]}